// Obstacle Entity Class
import { ENTITY_DIMENSIONS, ENTITY_DIMENSIONS_PERCENT, VISUAL_CONFIG, GAME_CONFIG } from '../constants/GameConfig.js';
import { getScaleManager } from '../utils/ScaleManager.js';

/**
 * Available obstacle character skin folders.
 * Fallback list used if dynamic manifest isn't available.
 * At runtime we prefer window.OBSTACLE_AVAILABLE_SKINS populated from
 * skins/obstacles/obstacle-skins.json (generated by a script or tool).
 */
const OBSTACLE_SKIN_NAMES = [
    'Abi','Adan','Elijah','Garret','Haven','Hayden','Jackson',
    'Jake','Javi','Jess','M','Mina','Nate','Randi','Tilly'
];

// Attempt to load dynamic skin list (non-blocking)
if (typeof window !== 'undefined' && !window.OBSTACLE_AVAILABLE_SKINS) {
    fetch('skins/obstacles/obstacle-skins.json', { cache: 'no-store' })
        .then(r => r.ok ? r.json() : [])
        .then(arr => {
            if (Array.isArray(arr) && arr.length) {
                window.OBSTACLE_AVAILABLE_SKINS = arr;
            }
        })
        .catch(() => { /* ignore */ });
}

export class Obstacle {
    constructor(type, canvas) {
        this.canvas = canvas;
        this.type = type; // 'low' or 'tall'
        this.scaleManager = getScaleManager();
        
        // Set dimensions based on type (percentage-based)
        const dimensions = type === 'tall' ? 
            ENTITY_DIMENSIONS_PERCENT.obstacle.tall : 
            ENTITY_DIMENSIONS_PERCENT.obstacle.low;
        
        this.widthPercent = dimensions.widthPercent;
        this.heightPercent = dimensions.heightPercent;
        
        // Position (percentages - will be set by spawn method)
        this.xPercent = 1.083; // 108.3% (off-screen right)
        this.yPercent = 0; // Will be set based on ground level
        this.speedPercent = 0; // Will be set by game speed
        
        // Pixel values (computed from percentages for rendering)
        this.width = this.scaleManager.uniformDimensionToPixelsX(this.widthPercent);
        this.height = this.scaleManager.uniformDimensionToPixelsY(this.heightPercent);
        this.x = this.scaleManager.toPixelsX(this.xPercent);
        this.y = this.scaleManager.toPixelsY(this.yPercent);
        this.speed = this.scaleManager.velocityToPixels(this.speedPercent, 'width');
        
        // Visual (fallback colors for low obstacles and when skins fail to load)
        this.color = type === 'tall' ? 
            VISUAL_CONFIG.obstacleColors.tall : 
            VISUAL_CONFIG.obstacleColors.low;
        
        // Animation properties for tall obstacles (articulated characters)
        if (type === 'tall') {
            this.animationFrame = 0;
            this.animationSpeed = 0.15; // Slightly slower than player
            
            // Joint angles for animation
            this.leftLegAngle = 0;
            this.rightLegAngle = 0;
            this.leftKneeAngle = 0;
            this.rightKneeAngle = 0;
            this.leftArmAngle = 0;
            this.rightArmAngle = 0;
            this.leftElbowAngle = 0;
            this.rightElbowAngle = 0;
            
            // Head animation properties
            this.headYOffset = 0;
            this.headXOffset = 0;
            this.headRotation = 0;
            this.headYOffsetTarget = 0;
            this.headXOffsetTarget = 0;
            this.headRotationTarget = 0;
            
            // Breathing animation
            this.breathingCycle = 0;
            this.isBreathingOut = false;
            
            // Skin properties
            this.skinName = null; // Will be set randomly
            this.skinImages = {}; // Will be loaded by AssetLoader
            this.skinsLoaded = false;

            // Stationary pose configuration
            this.animate = false; // keep tall obstacles stationary (no run cycle)
            this.setStopPose();
        }
        
        // Ragdoll properties
        this.isRagdolled = false;
        this.velocityX = 0;
        this.velocityY = 0;
        this.rotation = 0;
        this.rotationSpeed = 0;
        this.gravity = 0.5;
        this.groundY = 0; // Will be set when ragdolled
    }
    
    // Initialize random articulated skin for tall obstacles
    initRandomSkin() {
        try {
            // Build available list at runtime:
            // 1) Prefer dynamic manifest (window.OBSTACLE_AVAILABLE_SKINS)
            // 2) Fallback to static OBSTACLE_SKIN_NAMES
            // 3) Final fallback to 'Abi'
            const manifestList = (typeof window !== 'undefined' && Array.isArray(window.OBSTACLE_AVAILABLE_SKINS))
                ? window.OBSTACLE_AVAILABLE_SKINS : null;
            const available = (manifestList && manifestList.length) ? manifestList : OBSTACLE_SKIN_NAMES;

            // Optional: force a specific skin for testing
            const forced = (typeof window !== 'undefined' && window.OBSTACLE_FORCED_SKIN) || null;

            let chosen = 'Abi';
            if (forced && available.includes(forced)) {
                chosen = forced;
            } else if (available && available.length) {
                chosen = available[Math.floor(Math.random() * available.length)];
            }
            this.skinName = chosen;

            // Prepare image map
            this.skinImages = this.skinImages || {};
            const parts = ['head', 'head-open-mouth', 'torso', 'upper_arm', 'forearm', 'thigh', 'shin'];
            let loadedCount = 0;
            let attemptedCount = 0;

            parts.forEach(part => {
                const img = new Image();
                img.onload = () => {
                    loadedCount++;
                    // Mark loaded part
                    this.skinImages[part] = img;
                    // Consider skins ready after a few critical parts load
                    if (loadedCount >= 3) {
                        this.skinsLoaded = true;
                    }
                };
                img.onerror = () => {
                    attemptedCount++;
                };
                img.src = `skins/obstacles/${this.skinName}/${part}.png`;
                // Assign even before load for renderer checks
                this.skinImages[part] = img;
            });

            // Fallback: after short delay, if nothing loaded, keep rectangle rendering
            setTimeout(() => {
                if (!this.skinsLoaded) {
                    this.skinsLoaded = loadedCount > 0;
                }
            }, 400);
        } catch (e) {
            // Safe fallback to simple rectangle
            this.skinsLoaded = false;
        }
    }

    setPosition(groundY) {
        const groundYPercent = this.scaleManager.toPercentageY(groundY);
        this.yPercent = groundYPercent - this.heightPercent;
        this.y = this.scaleManager.toPixelsY(this.yPercent);
    }
    
    setSpeed(speed) {
        this.speedPercent = this.scaleManager.velocityToPercentage(speed, 'width');
        this.speed = speed; // Keep pixel speed for compatibility
    }
    
    triggerRagdoll(impactX, impactY) {
        if (this.isRagdolled) return;
        
        this.isRagdolled = true;
        this.groundY = this.canvas.height * 0.8; // Ground level
        
        // Apply impact forces based on collision point
        this.velocityX = -8 - Math.random() * 4; // Strong backward force
        this.velocityY = -12 - Math.random() * 8; // Upward force
        this.rotationSpeed = (Math.random() - 0.5) * 0.4; // Random rotation
    }
    
    update() {
        if (this.isRagdolled) {
            // Ragdoll physics
            this.x += this.velocityX;
            this.y += this.velocityY;
            this.velocityY += this.gravity; // Apply gravity
            this.rotation += this.rotationSpeed;
            
            // Ground collision for ragdoll
            if (this.y + this.height >= this.groundY) {
                this.y = this.groundY - this.height;
                this.velocityY *= -0.3; // Bounce with damping
                this.velocityX *= 0.8; // Friction
                this.rotationSpeed *= 0.9; // Damping
                
                // Stop bouncing if velocity is too low
                if (Math.abs(this.velocityY) < 1) {
                    this.velocityY = 0;
                }
            }
        } else {
            // Normal movement (obstacles move left across screen)
            this.xPercent -= this.speedPercent;
            this.x = this.scaleManager.toPixelsX(this.xPercent);
            
            // Tall obstacles: only update if animate flag is enabled
            if (this.type === 'tall' && this.animate) {
                this.updateAnimation();
            }
        }
    }
    
    // Stationary STOP pose for tall obstacles:
    // - Legs straight (standing)
    // - Front arm held out to the right (stop gesture)
    // - Back arm ~30 degrees from body
    setStopPose() {
        // Legs straight down
        this.leftLegAngle = 0;
        this.rightLegAngle = 0;
        this.leftKneeAngle = 0;
        this.rightKneeAngle = 0;

        // Arms:
        // Front arm (rendered in front of torso): hold out to the right like "STOP"
        // Coordinate note: 0 = straight down; +90 = to the right; -90 = to the left; 180 = up
        this.leftArmAngle = 90;      // horizontal to the right
        this.leftElbowAngle = 0;     // straight arm

        // Back arm (rendered behind torso): rotate to 330°
        this.rightArmAngle = 330;    // rotated to 330° per feedback
        this.rightElbowAngle = 10;   // small bend

        // Head neutral
        this.headYOffset = 0;
        this.headXOffset = 0;
        this.headRotation = 0;

        // Keep targets aligned (no animated lerp)
        this.headYOffsetTarget = 0;
        this.headXOffsetTarget = 0;
        this.headRotationTarget = 0;
    }

    updateAnimation() {
        // Running animation for tall obstacles
        this.animationFrame += this.animationSpeed;
        const runPhase = (this.animationFrame % 4) / 4 * Math.PI * 2;
        
        // Leg animation (slightly different from player for variety)
        this.leftLegAngle = -Math.sin(runPhase + Math.PI) * 25; // Opposite to player
        this.rightLegAngle = -Math.sin(runPhase) * 25;
        this.leftKneeAngle = Math.max(0, Math.sin(runPhase + Math.PI) * 40);
        this.rightKneeAngle = Math.max(0, Math.sin(runPhase) * 40);
        
        // Arm swing (more exaggerated for obstacles)
        const leftSwing = Math.sin(runPhase);
        const rightSwing = Math.sin(runPhase + Math.PI);
        this.leftArmAngle = 45 + (leftSwing > 0 ? leftSwing * 40 : leftSwing * 45);
        this.rightArmAngle = 45 + (rightSwing > 0 ? rightSwing * 40 : rightSwing * 45);
        this.leftElbowAngle = -Math.abs(Math.sin(runPhase)) * 80;
        this.rightElbowAngle = -Math.abs(Math.sin(runPhase + Math.PI)) * 80;
        
        // Breathing animation
        this.breathingCycle += 0.08; // Slightly different rate than player
        const breathPhase = Math.sin(this.breathingCycle);
        this.isBreathingOut = breathPhase > 0.2;
        
        // Head animation (more pronounced for obstacles)
        this.headYOffsetTarget = Math.abs(Math.sin(runPhase)) * 4;
        this.headXOffsetTarget = Math.sin(runPhase * 0.7) * 3;
        this.headRotationTarget = Math.sin(runPhase * 0.6) * 5;
        
        // Apply lerp for smoother head movement
        const lerpFactor = 0.12;
        this.headYOffset += (this.headYOffsetTarget - this.headYOffset) * lerpFactor;
        this.headXOffset += (this.headXOffsetTarget - this.headXOffset) * lerpFactor;
        this.headRotation += (this.headRotationTarget - this.headRotation) * lerpFactor;
    }
    
    isOffScreen() {
        if (this.isRagdolled) {
            // For ragdolled obstacles, check if they've fallen off screen
            return this.x + this.width < -100 || this.y > this.canvas.height + 100;
        }
        return this.xPercent + this.widthPercent < 0;
    }
    
    render(ctx) {
        ctx.save();
        
        if (this.isRagdolled) {
            // Render ragdolled obstacle with rotation
            ctx.translate(this.x + this.width/2, this.y + this.height/2);
            ctx.rotate(this.rotation);
            
            ctx.fillStyle = this.color;
            ctx.fillRect(-this.width/2, -this.height/2, this.width, this.height);
            
            // Add pattern with rotation
            ctx.fillStyle = 'rgba(255, 255, 255, 0.3)';
            ctx.fillRect(-this.width/2 + 5, -this.height/2 + 5, this.width - 10, 3);
        } else {
            // Normal rendering
            ctx.fillStyle = this.color;
            ctx.fillRect(this.x, this.y, this.width, this.height);
            
            // Add simple pattern to obstacles
            ctx.fillStyle = 'rgba(255, 255, 255, 0.3)';
            ctx.fillRect(this.x + 5, this.y + 5, this.width - 10, 3);
        }
        
        ctx.restore();
    }
    
    checkCollision(player) {
        return player.x < this.x + this.width &&
               player.x + player.width > this.x &&
               player.y < this.y + this.height &&
               player.y + player.height > this.y;
    }
}

// Factory function to create obstacles
export function createObstacle(type, canvas, groundY, speed) {
    const obstacle = new Obstacle(type, canvas);
    obstacle.setPosition(groundY);
    obstacle.setSpeed(speed);

    // For tall obstacles, assign a random articulated skin
    if (type === 'tall') {
        obstacle.initRandomSkin();
    }

    return obstacle;
}
